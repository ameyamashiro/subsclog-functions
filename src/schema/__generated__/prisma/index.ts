// Code generated by Prisma (prisma@1.29.0-beta.7). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U]

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>
  comment: (where?: CommentWhereInput) => Promise<boolean>
  owner: (where?: OwnerWhereInput) => Promise<boolean>
  review: (where?: ReviewWhereInput) => Promise<boolean>
  service: (where?: ServiceWhereInput) => Promise<boolean>
  user: (where?: UserWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
  $exists: Exists
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryPromise
  categories: (args?: {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Category>
  categoriesConnection: (args?: {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => CategoryConnectionPromise
  comment: (where: CommentWhereUniqueInput) => CommentPromise
  comments: (args?: {
    where?: CommentWhereInput
    orderBy?: CommentOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Comment>
  commentsConnection: (args?: {
    where?: CommentWhereInput
    orderBy?: CommentOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => CommentConnectionPromise
  owner: (where: OwnerWhereUniqueInput) => OwnerPromise
  owners: (args?: {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Owner>
  ownersConnection: (args?: {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => OwnerConnectionPromise
  review: (where: ReviewWhereUniqueInput) => ReviewPromise
  reviews: (args?: {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Review>
  reviewsConnection: (args?: {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => ReviewConnectionPromise
  service: (where: ServiceWhereUniqueInput) => ServicePromise
  services: (args?: {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Service>
  servicesConnection: (args?: {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => ServiceConnectionPromise
  user: (where: UserWhereUniqueInput) => UserPromise
  users: (args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<User>
  usersConnection: (args?: {
    where?: UserWhereInput
    orderBy?: UserOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => UserConnectionPromise
  node: (args: { id: ID_Output }) => Node

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise
  updateCategory: (args: {
    data: CategoryUpdateInput
    where: CategoryWhereUniqueInput
  }) => CategoryPromise
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput
    where?: CategoryWhereInput
  }) => BatchPayloadPromise
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput
    create: CategoryCreateInput
    update: CategoryUpdateInput
  }) => CategoryPromise
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise
  createComment: (data: CommentCreateInput) => CommentPromise
  updateComment: (args: {
    data: CommentUpdateInput
    where: CommentWhereUniqueInput
  }) => CommentPromise
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput
    where?: CommentWhereInput
  }) => BatchPayloadPromise
  upsertComment: (args: {
    where: CommentWhereUniqueInput
    create: CommentCreateInput
    update: CommentUpdateInput
  }) => CommentPromise
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise
  createOwner: (data: OwnerCreateInput) => OwnerPromise
  updateOwner: (args: {
    data: OwnerUpdateInput
    where: OwnerWhereUniqueInput
  }) => OwnerPromise
  updateManyOwners: (args: {
    data: OwnerUpdateManyMutationInput
    where?: OwnerWhereInput
  }) => BatchPayloadPromise
  upsertOwner: (args: {
    where: OwnerWhereUniqueInput
    create: OwnerCreateInput
    update: OwnerUpdateInput
  }) => OwnerPromise
  deleteOwner: (where: OwnerWhereUniqueInput) => OwnerPromise
  deleteManyOwners: (where?: OwnerWhereInput) => BatchPayloadPromise
  createReview: (data: ReviewCreateInput) => ReviewPromise
  updateReview: (args: {
    data: ReviewUpdateInput
    where: ReviewWhereUniqueInput
  }) => ReviewPromise
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput
    where?: ReviewWhereInput
  }) => BatchPayloadPromise
  upsertReview: (args: {
    where: ReviewWhereUniqueInput
    create: ReviewCreateInput
    update: ReviewUpdateInput
  }) => ReviewPromise
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise
  createService: (data: ServiceCreateInput) => ServicePromise
  updateService: (args: {
    data: ServiceUpdateInput
    where: ServiceWhereUniqueInput
  }) => ServicePromise
  updateManyServices: (args: {
    data: ServiceUpdateManyMutationInput
    where?: ServiceWhereInput
  }) => BatchPayloadPromise
  upsertService: (args: {
    where: ServiceWhereUniqueInput
    create: ServiceCreateInput
    update: ServiceUpdateInput
  }) => ServicePromise
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise
  createUser: (data: UserCreateInput) => UserPromise
  updateUser: (args: {
    data: UserUpdateInput
    where: UserWhereUniqueInput
  }) => UserPromise
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput
    where?: UserWhereInput
  }) => BatchPayloadPromise
  upsertUser: (args: {
    where: UserWhereUniqueInput
    create: UserCreateInput
    update: UserUpdateInput
  }) => UserPromise
  deleteUser: (where: UserWhereUniqueInput) => UserPromise
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise

  /**
   * Subscriptions
   */

  $subscribe: Subscription
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription
  owner: (
    where?: OwnerSubscriptionWhereInput
  ) => OwnerSubscriptionPayloadSubscription
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type ServiceOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'title_ASC'
  | 'title_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'url_ASC'
  | 'url_DESC'
  | 'photoURL_ASC'
  | 'photoURL_DESC'
  | 'yomigana_ASC'
  | 'yomigana_DESC'
  | 'price_ASC'
  | 'price_DESC'
  | 'freetrial_ASC'
  | 'freetrial_DESC'
  | 'note_ASC'
  | 'note_DESC'
  | 'place_ASC'
  | 'place_DESC'
  | 'address_ASC'
  | 'address_DESC'
  | 'tagline_ASC'
  | 'tagline_DESC'
  | 'inquiry_ASC'
  | 'inquiry_DESC'
  | 'multiplans_ASC'
  | 'multiplans_DESC'
  | 'phonenumber_ASC'
  | 'phonenumber_DESC'
  | 'rating_ASC'
  | 'rating_DESC'
  | 'ratingCount_ASC'
  | 'ratingCount_DESC'

export type ReviewOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'rate_ASC'
  | 'rate_DESC'
  | 'rating_ASC'
  | 'rating_DESC'
  | 'text_ASC'
  | 'text_DESC'
  | 'serviceId_ASC'
  | 'serviceId_DESC'
  | 'ownerId_ASC'
  | 'ownerId_DESC'

export type CategoryOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'shortDescription_ASC'
  | 'shortDescription_DESC'
  | 'description_ASC'
  | 'description_DESC'

export type CommentOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'text_ASC'
  | 'text_DESC'
  | 'ownerId_ASC'
  | 'ownerId_DESC'

export type OwnerOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'displayName_ASC'
  | 'displayName_DESC'
  | 'username_ASC'
  | 'username_DESC'
  | 'photoURL_ASC'
  | 'photoURL_DESC'

export type UserOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'name_ASC'
  | 'name_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export interface ReviewUpdateWithWhereUniqueWithoutServiceInput {
  where: ReviewWhereUniqueInput
  data: ReviewUpdateWithoutServiceDataInput
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface ReviewUpdateManyDataInput {
  rate?: Int
  rating?: Int
  text?: String
  serviceId?: String
  ownerId?: String
}

export interface ReviewWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  rate?: Int
  rate_not?: Int
  rate_in?: Int[] | Int
  rate_not_in?: Int[] | Int
  rate_lt?: Int
  rate_lte?: Int
  rate_gt?: Int
  rate_gte?: Int
  rating?: Int
  rating_not?: Int
  rating_in?: Int[] | Int
  rating_not_in?: Int[] | Int
  rating_lt?: Int
  rating_lte?: Int
  rating_gt?: Int
  rating_gte?: Int
  text?: String
  text_not?: String
  text_in?: String[] | String
  text_not_in?: String[] | String
  text_lt?: String
  text_lte?: String
  text_gt?: String
  text_gte?: String
  text_contains?: String
  text_not_contains?: String
  text_starts_with?: String
  text_not_starts_with?: String
  text_ends_with?: String
  text_not_ends_with?: String
  serviceId?: String
  serviceId_not?: String
  serviceId_in?: String[] | String
  serviceId_not_in?: String[] | String
  serviceId_lt?: String
  serviceId_lte?: String
  serviceId_gt?: String
  serviceId_gte?: String
  serviceId_contains?: String
  serviceId_not_contains?: String
  serviceId_starts_with?: String
  serviceId_not_starts_with?: String
  serviceId_ends_with?: String
  serviceId_not_ends_with?: String
  service?: ServiceWhereInput
  ownerId?: String
  ownerId_not?: String
  ownerId_in?: String[] | String
  ownerId_not_in?: String[] | String
  ownerId_lt?: String
  ownerId_lte?: String
  ownerId_gt?: String
  ownerId_gte?: String
  ownerId_contains?: String
  ownerId_not_contains?: String
  ownerId_starts_with?: String
  ownerId_not_starts_with?: String
  ownerId_ends_with?: String
  ownerId_not_ends_with?: String
  AND?: ReviewWhereInput[] | ReviewWhereInput
  OR?: ReviewWhereInput[] | ReviewWhereInput
  NOT?: ReviewWhereInput[] | ReviewWhereInput
}

export interface UserWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  name?: String
  name_not?: String
  name_in?: String[] | String
  name_not_in?: String[] | String
  name_lt?: String
  name_lte?: String
  name_gt?: String
  name_gte?: String
  name_contains?: String
  name_not_contains?: String
  name_starts_with?: String
  name_not_starts_with?: String
  name_ends_with?: String
  name_not_ends_with?: String
  AND?: UserWhereInput[] | UserWhereInput
  OR?: UserWhereInput[] | UserWhereInput
  NOT?: UserWhereInput[] | UserWhereInput
}

export interface CategoryCreateOneWithoutServicesInput {
  create?: CategoryCreateWithoutServicesInput
  connect?: CategoryWhereUniqueInput
}

export interface ServiceUpsertNestedInput {
  update: ServiceUpdateDataInput
  create: ServiceCreateInput
}

export interface ServiceUpsertWithWhereUniqueWithoutCategoryInput {
  where: ServiceWhereUniqueInput
  update: ServiceUpdateWithoutCategoryDataInput
  create: ServiceCreateWithoutCategoryInput
}

export interface CategoryUpsertWithoutServicesInput {
  update: CategoryUpdateWithoutServicesDataInput
  create: CategoryCreateWithoutServicesInput
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: ServiceWhereInput
  AND?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput
  OR?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput
  NOT?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput
}

export interface CategoryUpdateWithoutServicesDataInput {
  name?: String
  shortDescription?: String
  description?: String
}

export interface OwnerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: OwnerWhereInput
  AND?: OwnerSubscriptionWhereInput[] | OwnerSubscriptionWhereInput
  OR?: OwnerSubscriptionWhereInput[] | OwnerSubscriptionWhereInput
  NOT?: OwnerSubscriptionWhereInput[] | OwnerSubscriptionWhereInput
}

export interface CategoryUpdateOneWithoutServicesInput {
  create?: CategoryCreateWithoutServicesInput
  update?: CategoryUpdateWithoutServicesDataInput
  upsert?: CategoryUpsertWithoutServicesInput
  delete?: Boolean
  disconnect?: Boolean
  connect?: CategoryWhereUniqueInput
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: CategoryWhereInput
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface CommentWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  text?: String
  text_not?: String
  text_in?: String[] | String
  text_not_in?: String[] | String
  text_lt?: String
  text_lte?: String
  text_gt?: String
  text_gte?: String
  text_contains?: String
  text_not_contains?: String
  text_starts_with?: String
  text_not_starts_with?: String
  text_ends_with?: String
  text_not_ends_with?: String
  service?: ServiceWhereInput
  ownerId?: String
  ownerId_not?: String
  ownerId_in?: String[] | String
  ownerId_not_in?: String[] | String
  ownerId_lt?: String
  ownerId_lte?: String
  ownerId_gt?: String
  ownerId_gte?: String
  ownerId_contains?: String
  ownerId_not_contains?: String
  ownerId_starts_with?: String
  ownerId_not_starts_with?: String
  ownerId_ends_with?: String
  ownerId_not_ends_with?: String
  AND?: CommentWhereInput[] | CommentWhereInput
  OR?: CommentWhereInput[] | CommentWhereInput
  NOT?: CommentWhereInput[] | CommentWhereInput
}

export interface CategoryCreateInput {
  name: String
  services?: ServiceCreateManyWithoutCategoryInput
  shortDescription: String
  description: String
}

export interface UserCreateInput {
  name: String
}

export interface ServiceCreateManyWithoutCategoryInput {
  create?:
    | ServiceCreateWithoutCategoryInput[]
    | ServiceCreateWithoutCategoryInput
  connect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput
}

export interface ServiceUpdateInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  category?: CategoryUpdateOneWithoutServicesInput
  rating?: Int
  ratingCount?: Int
  reviews?: ReviewUpdateManyWithoutServiceInput
}

export interface ServiceCreateWithoutCategoryInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  rating?: Int
  ratingCount?: Int
  reviews?: ReviewCreateManyWithoutServiceInput
}

export interface ReviewUpdateManyMutationInput {
  rate?: Int
  rating?: Int
  text?: String
  serviceId?: String
  ownerId?: String
}

export interface ReviewCreateManyWithoutServiceInput {
  create?: ReviewCreateWithoutServiceInput[] | ReviewCreateWithoutServiceInput
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput
}

export interface ServiceUpsertWithoutReviewsInput {
  update: ServiceUpdateWithoutReviewsDataInput
  create: ServiceCreateWithoutReviewsInput
}

export interface ReviewCreateWithoutServiceInput {
  rate?: Int
  rating: Int
  text: String
  serviceId: String
  ownerId?: String
}

export interface ServiceUpdateOneRequiredWithoutReviewsInput {
  create?: ServiceCreateWithoutReviewsInput
  update?: ServiceUpdateWithoutReviewsDataInput
  upsert?: ServiceUpsertWithoutReviewsInput
  connect?: ServiceWhereUniqueInput
}

export interface CategoryUpdateInput {
  name?: String
  services?: ServiceUpdateManyWithoutCategoryInput
  shortDescription?: String
  description?: String
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface ServiceUpdateManyWithoutCategoryInput {
  create?:
    | ServiceCreateWithoutCategoryInput[]
    | ServiceCreateWithoutCategoryInput
  delete?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput
  connect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput
  set?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput
  disconnect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput
  update?:
    | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    | ServiceUpdateWithWhereUniqueWithoutCategoryInput
  upsert?:
    | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    | ServiceUpsertWithWhereUniqueWithoutCategoryInput
  deleteMany?: ServiceScalarWhereInput[] | ServiceScalarWhereInput
  updateMany?:
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput
}

export interface ServiceCreateOneWithoutReviewsInput {
  create?: ServiceCreateWithoutReviewsInput
  connect?: ServiceWhereUniqueInput
}

export interface ServiceUpdateWithWhereUniqueWithoutCategoryInput {
  where: ServiceWhereUniqueInput
  data: ServiceUpdateWithoutCategoryDataInput
}

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface ServiceUpdateWithoutCategoryDataInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  rating?: Int
  ratingCount?: Int
  reviews?: ReviewUpdateManyWithoutServiceInput
}

export interface OwnerUpdateInput {
  displayName?: String
  username?: String
  photoURL?: String
}

export interface ReviewUpdateManyWithoutServiceInput {
  create?: ReviewCreateWithoutServiceInput[] | ReviewCreateWithoutServiceInput
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput
  set?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput
  update?:
    | ReviewUpdateWithWhereUniqueWithoutServiceInput[]
    | ReviewUpdateWithWhereUniqueWithoutServiceInput
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutServiceInput[]
    | ReviewUpsertWithWhereUniqueWithoutServiceInput
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface ServiceUpdateDataInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  category?: CategoryUpdateOneWithoutServicesInput
  rating?: Int
  ratingCount?: Int
  reviews?: ReviewUpdateManyWithoutServiceInput
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: UserWhereInput
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput
}

export interface ReviewUpdateWithoutServiceDataInput {
  rate?: Int
  rating?: Int
  text?: String
  serviceId?: String
  ownerId?: String
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: CommentWhereInput
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput
}

export interface ReviewUpsertWithWhereUniqueWithoutServiceInput {
  where: ReviewWhereUniqueInput
  update: ReviewUpdateWithoutServiceDataInput
  create: ReviewCreateWithoutServiceInput
}

export interface UserUpdateInput {
  name?: String
}

export interface ReviewScalarWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  rate?: Int
  rate_not?: Int
  rate_in?: Int[] | Int
  rate_not_in?: Int[] | Int
  rate_lt?: Int
  rate_lte?: Int
  rate_gt?: Int
  rate_gte?: Int
  rating?: Int
  rating_not?: Int
  rating_in?: Int[] | Int
  rating_not_in?: Int[] | Int
  rating_lt?: Int
  rating_lte?: Int
  rating_gt?: Int
  rating_gte?: Int
  text?: String
  text_not?: String
  text_in?: String[] | String
  text_not_in?: String[] | String
  text_lt?: String
  text_lte?: String
  text_gt?: String
  text_gte?: String
  text_contains?: String
  text_not_contains?: String
  text_starts_with?: String
  text_not_starts_with?: String
  text_ends_with?: String
  text_not_ends_with?: String
  serviceId?: String
  serviceId_not?: String
  serviceId_in?: String[] | String
  serviceId_not_in?: String[] | String
  serviceId_lt?: String
  serviceId_lte?: String
  serviceId_gt?: String
  serviceId_gte?: String
  serviceId_contains?: String
  serviceId_not_contains?: String
  serviceId_starts_with?: String
  serviceId_not_starts_with?: String
  serviceId_ends_with?: String
  serviceId_not_ends_with?: String
  ownerId?: String
  ownerId_not?: String
  ownerId_in?: String[] | String
  ownerId_not_in?: String[] | String
  ownerId_lt?: String
  ownerId_lte?: String
  ownerId_gt?: String
  ownerId_gte?: String
  ownerId_contains?: String
  ownerId_not_contains?: String
  ownerId_starts_with?: String
  ownerId_not_starts_with?: String
  ownerId_ends_with?: String
  ownerId_not_ends_with?: String
  AND?: ReviewScalarWhereInput[] | ReviewScalarWhereInput
  OR?: ReviewScalarWhereInput[] | ReviewScalarWhereInput
  NOT?: ReviewScalarWhereInput[] | ReviewScalarWhereInput
}

export interface ServiceUpdateManyMutationInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  rating?: Int
  ratingCount?: Int
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput
  data: ReviewUpdateManyDataInput
}

export interface OwnerWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  displayName?: String
  displayName_not?: String
  displayName_in?: String[] | String
  displayName_not_in?: String[] | String
  displayName_lt?: String
  displayName_lte?: String
  displayName_gt?: String
  displayName_gte?: String
  displayName_contains?: String
  displayName_not_contains?: String
  displayName_starts_with?: String
  displayName_not_starts_with?: String
  displayName_ends_with?: String
  displayName_not_ends_with?: String
  username?: String
  username_not?: String
  username_in?: String[] | String
  username_not_in?: String[] | String
  username_lt?: String
  username_lte?: String
  username_gt?: String
  username_gte?: String
  username_contains?: String
  username_not_contains?: String
  username_starts_with?: String
  username_not_starts_with?: String
  username_ends_with?: String
  username_not_ends_with?: String
  photoURL?: String
  photoURL_not?: String
  photoURL_in?: String[] | String
  photoURL_not_in?: String[] | String
  photoURL_lt?: String
  photoURL_lte?: String
  photoURL_gt?: String
  photoURL_gte?: String
  photoURL_contains?: String
  photoURL_not_contains?: String
  photoURL_starts_with?: String
  photoURL_not_starts_with?: String
  photoURL_ends_with?: String
  photoURL_not_ends_with?: String
  AND?: OwnerWhereInput[] | OwnerWhereInput
  OR?: OwnerWhereInput[] | OwnerWhereInput
  NOT?: OwnerWhereInput[] | OwnerWhereInput
}

export interface ServiceUpdateOneRequiredInput {
  create?: ServiceCreateInput
  update?: ServiceUpdateDataInput
  upsert?: ServiceUpsertNestedInput
  connect?: ServiceWhereUniqueInput
}

export interface ReviewUpdateInput {
  rate?: Int
  rating?: Int
  text?: String
  serviceId?: String
  service?: ServiceUpdateOneRequiredWithoutReviewsInput
  ownerId?: String
}

export interface CategoryWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  name?: String
  name_not?: String
  name_in?: String[] | String
  name_not_in?: String[] | String
  name_lt?: String
  name_lte?: String
  name_gt?: String
  name_gte?: String
  name_contains?: String
  name_not_contains?: String
  name_starts_with?: String
  name_not_starts_with?: String
  name_ends_with?: String
  name_not_ends_with?: String
  services_every?: ServiceWhereInput
  services_some?: ServiceWhereInput
  services_none?: ServiceWhereInput
  shortDescription?: String
  shortDescription_not?: String
  shortDescription_in?: String[] | String
  shortDescription_not_in?: String[] | String
  shortDescription_lt?: String
  shortDescription_lte?: String
  shortDescription_gt?: String
  shortDescription_gte?: String
  shortDescription_contains?: String
  shortDescription_not_contains?: String
  shortDescription_starts_with?: String
  shortDescription_not_starts_with?: String
  shortDescription_ends_with?: String
  shortDescription_not_ends_with?: String
  description?: String
  description_not?: String
  description_in?: String[] | String
  description_not_in?: String[] | String
  description_lt?: String
  description_lte?: String
  description_gt?: String
  description_gte?: String
  description_contains?: String
  description_not_contains?: String
  description_starts_with?: String
  description_not_starts_with?: String
  description_ends_with?: String
  description_not_ends_with?: String
  AND?: CategoryWhereInput[] | CategoryWhereInput
  OR?: CategoryWhereInput[] | CategoryWhereInput
  NOT?: CategoryWhereInput[] | CategoryWhereInput
}

export interface ReviewCreateInput {
  rate?: Int
  rating: Int
  text: String
  serviceId: String
  service: ServiceCreateOneWithoutReviewsInput
  ownerId?: String
}

export interface ServiceScalarWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  title?: String
  title_not?: String
  title_in?: String[] | String
  title_not_in?: String[] | String
  title_lt?: String
  title_lte?: String
  title_gt?: String
  title_gte?: String
  title_contains?: String
  title_not_contains?: String
  title_starts_with?: String
  title_not_starts_with?: String
  title_ends_with?: String
  title_not_ends_with?: String
  description?: String
  description_not?: String
  description_in?: String[] | String
  description_not_in?: String[] | String
  description_lt?: String
  description_lte?: String
  description_gt?: String
  description_gte?: String
  description_contains?: String
  description_not_contains?: String
  description_starts_with?: String
  description_not_starts_with?: String
  description_ends_with?: String
  description_not_ends_with?: String
  url?: String
  url_not?: String
  url_in?: String[] | String
  url_not_in?: String[] | String
  url_lt?: String
  url_lte?: String
  url_gt?: String
  url_gte?: String
  url_contains?: String
  url_not_contains?: String
  url_starts_with?: String
  url_not_starts_with?: String
  url_ends_with?: String
  url_not_ends_with?: String
  photoURL?: String
  photoURL_not?: String
  photoURL_in?: String[] | String
  photoURL_not_in?: String[] | String
  photoURL_lt?: String
  photoURL_lte?: String
  photoURL_gt?: String
  photoURL_gte?: String
  photoURL_contains?: String
  photoURL_not_contains?: String
  photoURL_starts_with?: String
  photoURL_not_starts_with?: String
  photoURL_ends_with?: String
  photoURL_not_ends_with?: String
  yomigana?: String
  yomigana_not?: String
  yomigana_in?: String[] | String
  yomigana_not_in?: String[] | String
  yomigana_lt?: String
  yomigana_lte?: String
  yomigana_gt?: String
  yomigana_gte?: String
  yomigana_contains?: String
  yomigana_not_contains?: String
  yomigana_starts_with?: String
  yomigana_not_starts_with?: String
  yomigana_ends_with?: String
  yomigana_not_ends_with?: String
  price?: Float
  price_not?: Float
  price_in?: Float[] | Float
  price_not_in?: Float[] | Float
  price_lt?: Float
  price_lte?: Float
  price_gt?: Float
  price_gte?: Float
  freetrial?: String
  freetrial_not?: String
  freetrial_in?: String[] | String
  freetrial_not_in?: String[] | String
  freetrial_lt?: String
  freetrial_lte?: String
  freetrial_gt?: String
  freetrial_gte?: String
  freetrial_contains?: String
  freetrial_not_contains?: String
  freetrial_starts_with?: String
  freetrial_not_starts_with?: String
  freetrial_ends_with?: String
  freetrial_not_ends_with?: String
  note?: String
  note_not?: String
  note_in?: String[] | String
  note_not_in?: String[] | String
  note_lt?: String
  note_lte?: String
  note_gt?: String
  note_gte?: String
  note_contains?: String
  note_not_contains?: String
  note_starts_with?: String
  note_not_starts_with?: String
  note_ends_with?: String
  note_not_ends_with?: String
  place?: String
  place_not?: String
  place_in?: String[] | String
  place_not_in?: String[] | String
  place_lt?: String
  place_lte?: String
  place_gt?: String
  place_gte?: String
  place_contains?: String
  place_not_contains?: String
  place_starts_with?: String
  place_not_starts_with?: String
  place_ends_with?: String
  place_not_ends_with?: String
  address?: String
  address_not?: String
  address_in?: String[] | String
  address_not_in?: String[] | String
  address_lt?: String
  address_lte?: String
  address_gt?: String
  address_gte?: String
  address_contains?: String
  address_not_contains?: String
  address_starts_with?: String
  address_not_starts_with?: String
  address_ends_with?: String
  address_not_ends_with?: String
  tagline?: String
  tagline_not?: String
  tagline_in?: String[] | String
  tagline_not_in?: String[] | String
  tagline_lt?: String
  tagline_lte?: String
  tagline_gt?: String
  tagline_gte?: String
  tagline_contains?: String
  tagline_not_contains?: String
  tagline_starts_with?: String
  tagline_not_starts_with?: String
  tagline_ends_with?: String
  tagline_not_ends_with?: String
  inquiry?: String
  inquiry_not?: String
  inquiry_in?: String[] | String
  inquiry_not_in?: String[] | String
  inquiry_lt?: String
  inquiry_lte?: String
  inquiry_gt?: String
  inquiry_gte?: String
  inquiry_contains?: String
  inquiry_not_contains?: String
  inquiry_starts_with?: String
  inquiry_not_starts_with?: String
  inquiry_ends_with?: String
  inquiry_not_ends_with?: String
  multiplans?: String
  multiplans_not?: String
  multiplans_in?: String[] | String
  multiplans_not_in?: String[] | String
  multiplans_lt?: String
  multiplans_lte?: String
  multiplans_gt?: String
  multiplans_gte?: String
  multiplans_contains?: String
  multiplans_not_contains?: String
  multiplans_starts_with?: String
  multiplans_not_starts_with?: String
  multiplans_ends_with?: String
  multiplans_not_ends_with?: String
  phonenumber?: String
  phonenumber_not?: String
  phonenumber_in?: String[] | String
  phonenumber_not_in?: String[] | String
  phonenumber_lt?: String
  phonenumber_lte?: String
  phonenumber_gt?: String
  phonenumber_gte?: String
  phonenumber_contains?: String
  phonenumber_not_contains?: String
  phonenumber_starts_with?: String
  phonenumber_not_starts_with?: String
  phonenumber_ends_with?: String
  phonenumber_not_ends_with?: String
  rating?: Int
  rating_not?: Int
  rating_in?: Int[] | Int
  rating_not_in?: Int[] | Int
  rating_lt?: Int
  rating_lte?: Int
  rating_gt?: Int
  rating_gte?: Int
  ratingCount?: Int
  ratingCount_not?: Int
  ratingCount_in?: Int[] | Int
  ratingCount_not_in?: Int[] | Int
  ratingCount_lt?: Int
  ratingCount_lte?: Int
  ratingCount_gt?: Int
  ratingCount_gte?: Int
  AND?: ServiceScalarWhereInput[] | ServiceScalarWhereInput
  OR?: ServiceScalarWhereInput[] | ServiceScalarWhereInput
  NOT?: ServiceScalarWhereInput[] | ServiceScalarWhereInput
}

export interface OwnerCreateInput {
  displayName: String
  username: String
  photoURL?: String
}

export interface ServiceUpdateManyWithWhereNestedInput {
  where: ServiceScalarWhereInput
  data: ServiceUpdateManyDataInput
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: ReviewWhereInput
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput
}

export interface ServiceUpdateManyDataInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  rating?: Int
  ratingCount?: Int
}

export interface ServiceWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  createdAt?: DateTimeInput
  createdAt_not?: DateTimeInput
  createdAt_in?: DateTimeInput[] | DateTimeInput
  createdAt_not_in?: DateTimeInput[] | DateTimeInput
  createdAt_lt?: DateTimeInput
  createdAt_lte?: DateTimeInput
  createdAt_gt?: DateTimeInput
  createdAt_gte?: DateTimeInput
  updatedAt?: DateTimeInput
  updatedAt_not?: DateTimeInput
  updatedAt_in?: DateTimeInput[] | DateTimeInput
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput
  updatedAt_lt?: DateTimeInput
  updatedAt_lte?: DateTimeInput
  updatedAt_gt?: DateTimeInput
  updatedAt_gte?: DateTimeInput
  title?: String
  title_not?: String
  title_in?: String[] | String
  title_not_in?: String[] | String
  title_lt?: String
  title_lte?: String
  title_gt?: String
  title_gte?: String
  title_contains?: String
  title_not_contains?: String
  title_starts_with?: String
  title_not_starts_with?: String
  title_ends_with?: String
  title_not_ends_with?: String
  description?: String
  description_not?: String
  description_in?: String[] | String
  description_not_in?: String[] | String
  description_lt?: String
  description_lte?: String
  description_gt?: String
  description_gte?: String
  description_contains?: String
  description_not_contains?: String
  description_starts_with?: String
  description_not_starts_with?: String
  description_ends_with?: String
  description_not_ends_with?: String
  url?: String
  url_not?: String
  url_in?: String[] | String
  url_not_in?: String[] | String
  url_lt?: String
  url_lte?: String
  url_gt?: String
  url_gte?: String
  url_contains?: String
  url_not_contains?: String
  url_starts_with?: String
  url_not_starts_with?: String
  url_ends_with?: String
  url_not_ends_with?: String
  photoURL?: String
  photoURL_not?: String
  photoURL_in?: String[] | String
  photoURL_not_in?: String[] | String
  photoURL_lt?: String
  photoURL_lte?: String
  photoURL_gt?: String
  photoURL_gte?: String
  photoURL_contains?: String
  photoURL_not_contains?: String
  photoURL_starts_with?: String
  photoURL_not_starts_with?: String
  photoURL_ends_with?: String
  photoURL_not_ends_with?: String
  yomigana?: String
  yomigana_not?: String
  yomigana_in?: String[] | String
  yomigana_not_in?: String[] | String
  yomigana_lt?: String
  yomigana_lte?: String
  yomigana_gt?: String
  yomigana_gte?: String
  yomigana_contains?: String
  yomigana_not_contains?: String
  yomigana_starts_with?: String
  yomigana_not_starts_with?: String
  yomigana_ends_with?: String
  yomigana_not_ends_with?: String
  price?: Float
  price_not?: Float
  price_in?: Float[] | Float
  price_not_in?: Float[] | Float
  price_lt?: Float
  price_lte?: Float
  price_gt?: Float
  price_gte?: Float
  freetrial?: String
  freetrial_not?: String
  freetrial_in?: String[] | String
  freetrial_not_in?: String[] | String
  freetrial_lt?: String
  freetrial_lte?: String
  freetrial_gt?: String
  freetrial_gte?: String
  freetrial_contains?: String
  freetrial_not_contains?: String
  freetrial_starts_with?: String
  freetrial_not_starts_with?: String
  freetrial_ends_with?: String
  freetrial_not_ends_with?: String
  note?: String
  note_not?: String
  note_in?: String[] | String
  note_not_in?: String[] | String
  note_lt?: String
  note_lte?: String
  note_gt?: String
  note_gte?: String
  note_contains?: String
  note_not_contains?: String
  note_starts_with?: String
  note_not_starts_with?: String
  note_ends_with?: String
  note_not_ends_with?: String
  place?: String
  place_not?: String
  place_in?: String[] | String
  place_not_in?: String[] | String
  place_lt?: String
  place_lte?: String
  place_gt?: String
  place_gte?: String
  place_contains?: String
  place_not_contains?: String
  place_starts_with?: String
  place_not_starts_with?: String
  place_ends_with?: String
  place_not_ends_with?: String
  address?: String
  address_not?: String
  address_in?: String[] | String
  address_not_in?: String[] | String
  address_lt?: String
  address_lte?: String
  address_gt?: String
  address_gte?: String
  address_contains?: String
  address_not_contains?: String
  address_starts_with?: String
  address_not_starts_with?: String
  address_ends_with?: String
  address_not_ends_with?: String
  tagline?: String
  tagline_not?: String
  tagline_in?: String[] | String
  tagline_not_in?: String[] | String
  tagline_lt?: String
  tagline_lte?: String
  tagline_gt?: String
  tagline_gte?: String
  tagline_contains?: String
  tagline_not_contains?: String
  tagline_starts_with?: String
  tagline_not_starts_with?: String
  tagline_ends_with?: String
  tagline_not_ends_with?: String
  inquiry?: String
  inquiry_not?: String
  inquiry_in?: String[] | String
  inquiry_not_in?: String[] | String
  inquiry_lt?: String
  inquiry_lte?: String
  inquiry_gt?: String
  inquiry_gte?: String
  inquiry_contains?: String
  inquiry_not_contains?: String
  inquiry_starts_with?: String
  inquiry_not_starts_with?: String
  inquiry_ends_with?: String
  inquiry_not_ends_with?: String
  multiplans?: String
  multiplans_not?: String
  multiplans_in?: String[] | String
  multiplans_not_in?: String[] | String
  multiplans_lt?: String
  multiplans_lte?: String
  multiplans_gt?: String
  multiplans_gte?: String
  multiplans_contains?: String
  multiplans_not_contains?: String
  multiplans_starts_with?: String
  multiplans_not_starts_with?: String
  multiplans_ends_with?: String
  multiplans_not_ends_with?: String
  phonenumber?: String
  phonenumber_not?: String
  phonenumber_in?: String[] | String
  phonenumber_not_in?: String[] | String
  phonenumber_lt?: String
  phonenumber_lte?: String
  phonenumber_gt?: String
  phonenumber_gte?: String
  phonenumber_contains?: String
  phonenumber_not_contains?: String
  phonenumber_starts_with?: String
  phonenumber_not_starts_with?: String
  phonenumber_ends_with?: String
  phonenumber_not_ends_with?: String
  category?: CategoryWhereInput
  rating?: Int
  rating_not?: Int
  rating_in?: Int[] | Int
  rating_not_in?: Int[] | Int
  rating_lt?: Int
  rating_lte?: Int
  rating_gt?: Int
  rating_gte?: Int
  ratingCount?: Int
  ratingCount_not?: Int
  ratingCount_in?: Int[] | Int
  ratingCount_not_in?: Int[] | Int
  ratingCount_lt?: Int
  ratingCount_lte?: Int
  ratingCount_gt?: Int
  ratingCount_gte?: Int
  reviews_every?: ReviewWhereInput
  reviews_some?: ReviewWhereInput
  reviews_none?: ReviewWhereInput
  AND?: ServiceWhereInput[] | ServiceWhereInput
  OR?: ServiceWhereInput[] | ServiceWhereInput
  NOT?: ServiceWhereInput[] | ServiceWhereInput
}

export interface CategoryUpdateManyMutationInput {
  name?: String
  shortDescription?: String
  description?: String
}

export interface ServiceUpdateWithoutReviewsDataInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  category?: CategoryUpdateOneWithoutServicesInput
  rating?: Int
  ratingCount?: Int
}

export interface CommentUpdateInput {
  text?: String
  service?: ServiceUpdateOneRequiredInput
  ownerId?: String
}

export interface OwnerUpdateManyMutationInput {
  displayName?: String
  username?: String
  photoURL?: String
}

export interface ServiceCreateInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  category?: CategoryCreateOneWithoutServicesInput
  rating?: Int
  ratingCount?: Int
  reviews?: ReviewCreateManyWithoutServiceInput
}

export interface ServiceCreateOneInput {
  create?: ServiceCreateInput
  connect?: ServiceWhereUniqueInput
}

export interface CommentCreateInput {
  text: String
  service: ServiceCreateOneInput
  ownerId?: String
}

export interface CategoryCreateWithoutServicesInput {
  name: String
  shortDescription: String
  description: String
}

export interface CommentUpdateManyMutationInput {
  text?: String
  ownerId?: String
}

export interface ServiceCreateWithoutReviewsInput {
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  category?: CategoryCreateOneWithoutServicesInput
  rating?: Int
  ratingCount?: Int
}

export type OwnerWhereUniqueInput = AtLeastOne<{
  id: ID_Input
  username?: String
}>

export interface UserUpdateManyMutationInput {
  name?: String
}

export interface NodeNode {
  id: ID_Output
}

export interface UserPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  name: String
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  name: () => Promise<String>
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  name: () => Promise<AsyncIterator<String>>
}

export interface CommentConnection {
  pageInfo: PageInfo
  edges: CommentEdge[]
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<CommentEdge>>() => T
  aggregate: <T = AggregateCommentPromise>() => T
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T
  aggregate: <T = AggregateCommentSubscription>() => T
}

export interface Service {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  rating?: Int
  ratingCount?: Int
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  title: () => Promise<String>
  description: () => Promise<String>
  url: () => Promise<String>
  photoURL: () => Promise<String>
  yomigana: () => Promise<String>
  price: () => Promise<Float>
  freetrial: () => Promise<String>
  note: () => Promise<String>
  place: () => Promise<String>
  address: () => Promise<String>
  tagline: () => Promise<String>
  inquiry: () => Promise<String>
  multiplans: () => Promise<String>
  phonenumber: () => Promise<String>
  category: <T = CategoryPromise>() => T
  rating: () => Promise<Int>
  ratingCount: () => Promise<Int>
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  title: () => Promise<AsyncIterator<String>>
  description: () => Promise<AsyncIterator<String>>
  url: () => Promise<AsyncIterator<String>>
  photoURL: () => Promise<AsyncIterator<String>>
  yomigana: () => Promise<AsyncIterator<String>>
  price: () => Promise<AsyncIterator<Float>>
  freetrial: () => Promise<AsyncIterator<String>>
  note: () => Promise<AsyncIterator<String>>
  place: () => Promise<AsyncIterator<String>>
  address: () => Promise<AsyncIterator<String>>
  tagline: () => Promise<AsyncIterator<String>>
  inquiry: () => Promise<AsyncIterator<String>>
  multiplans: () => Promise<AsyncIterator<String>>
  phonenumber: () => Promise<AsyncIterator<String>>
  category: <T = CategorySubscription>() => T
  rating: () => Promise<AsyncIterator<Int>>
  ratingCount: () => Promise<AsyncIterator<Int>>
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface AggregateComment {
  count: Int
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface ReviewPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  rate?: Int
  rating: Int
  text: String
  serviceId: String
  ownerId?: String
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  rate: () => Promise<Int>
  rating: () => Promise<Int>
  text: () => Promise<String>
  serviceId: () => Promise<String>
  ownerId: () => Promise<String>
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  rate: () => Promise<AsyncIterator<Int>>
  rating: () => Promise<AsyncIterator<Int>>
  text: () => Promise<AsyncIterator<String>>
  serviceId: () => Promise<AsyncIterator<String>>
  ownerId: () => Promise<AsyncIterator<String>>
}

export interface CommentEdge {
  node: Comment
  cursor: String
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T
  cursor: () => Promise<String>
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface Comment {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  text: String
  ownerId?: String
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  text: () => Promise<String>
  service: <T = ServicePromise>() => T
  ownerId: () => Promise<String>
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  text: () => Promise<AsyncIterator<String>>
  service: <T = ServiceSubscription>() => T
  ownerId: () => Promise<AsyncIterator<String>>
}

export interface BatchPayload {
  count: Long
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>
}

export interface UserEdge {
  node: User
  cursor: String
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T
  cursor: () => Promise<String>
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface ServicePreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  title?: String
  description?: String
  url?: String
  photoURL?: String
  yomigana?: String
  price?: Float
  freetrial?: String
  note?: String
  place?: String
  address?: String
  tagline?: String
  inquiry?: String
  multiplans?: String
  phonenumber?: String
  rating?: Int
  ratingCount?: Int
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  title: () => Promise<String>
  description: () => Promise<String>
  url: () => Promise<String>
  photoURL: () => Promise<String>
  yomigana: () => Promise<String>
  price: () => Promise<Float>
  freetrial: () => Promise<String>
  note: () => Promise<String>
  place: () => Promise<String>
  address: () => Promise<String>
  tagline: () => Promise<String>
  inquiry: () => Promise<String>
  multiplans: () => Promise<String>
  phonenumber: () => Promise<String>
  rating: () => Promise<Int>
  ratingCount: () => Promise<Int>
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  title: () => Promise<AsyncIterator<String>>
  description: () => Promise<AsyncIterator<String>>
  url: () => Promise<AsyncIterator<String>>
  photoURL: () => Promise<AsyncIterator<String>>
  yomigana: () => Promise<AsyncIterator<String>>
  price: () => Promise<AsyncIterator<Float>>
  freetrial: () => Promise<AsyncIterator<String>>
  note: () => Promise<AsyncIterator<String>>
  place: () => Promise<AsyncIterator<String>>
  address: () => Promise<AsyncIterator<String>>
  tagline: () => Promise<AsyncIterator<String>>
  inquiry: () => Promise<AsyncIterator<String>>
  multiplans: () => Promise<AsyncIterator<String>>
  phonenumber: () => Promise<AsyncIterator<String>>
  rating: () => Promise<AsyncIterator<Int>>
  ratingCount: () => Promise<AsyncIterator<Int>>
}

export interface UserSubscriptionPayload {
  mutation: MutationType
  node: User
  updatedFields: String[]
  previousValues: UserPreviousValues
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = UserPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = UserPreviousValuesPromise>() => T
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = UserSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = UserPreviousValuesSubscription>() => T
}

export interface AggregateCategory {
  count: Int
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface AggregateService {
  count: Int
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface CategoryEdge {
  node: Category
  cursor: String
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T
  cursor: () => Promise<String>
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface ServiceConnection {
  pageInfo: PageInfo
  edges: ServiceEdge[]
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ServiceEdge>>() => T
  aggregate: <T = AggregateServicePromise>() => T
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T
  aggregate: <T = AggregateServiceSubscription>() => T
}

export interface Category {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  name: String
  shortDescription: String
  description: String
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  name: () => Promise<String>
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  shortDescription: () => Promise<String>
  description: () => Promise<String>
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  name: () => Promise<AsyncIterator<String>>
  services: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  shortDescription: () => Promise<AsyncIterator<String>>
  description: () => Promise<AsyncIterator<String>>
}

export interface ReviewEdge {
  node: Review
  cursor: String
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T
  cursor: () => Promise<String>
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface CategorySubscriptionPayload {
  mutation: MutationType
  node: Category
  updatedFields: String[]
  previousValues: CategoryPreviousValues
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = CategoryPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = CategoryPreviousValuesPromise>() => T
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = CategorySubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = CategoryPreviousValuesSubscription>() => T
}

export interface AggregateOwner {
  count: Int
}

export interface AggregateOwnerPromise
  extends Promise<AggregateOwner>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateOwnerSubscription
  extends Promise<AsyncIterator<AggregateOwner>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface CategoryPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  name: String
  shortDescription: String
  description: String
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  name: () => Promise<String>
  shortDescription: () => Promise<String>
  description: () => Promise<String>
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  name: () => Promise<AsyncIterator<String>>
  shortDescription: () => Promise<AsyncIterator<String>>
  description: () => Promise<AsyncIterator<String>>
}

export interface OwnerConnection {
  pageInfo: PageInfo
  edges: OwnerEdge[]
}

export interface OwnerConnectionPromise
  extends Promise<OwnerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<OwnerEdge>>() => T
  aggregate: <T = AggregateOwnerPromise>() => T
}

export interface OwnerConnectionSubscription
  extends Promise<AsyncIterator<OwnerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<OwnerEdgeSubscription>>>() => T
  aggregate: <T = AggregateOwnerSubscription>() => T
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType
  node: Service
  updatedFields: String[]
  previousValues: ServicePreviousValues
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ServicePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ServicePreviousValuesPromise>() => T
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ServiceSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ServicePreviousValuesSubscription>() => T
}

export interface Owner {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  displayName: String
  username: String
  photoURL?: String
}

export interface OwnerPromise extends Promise<Owner>, Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  displayName: () => Promise<String>
  username: () => Promise<String>
  photoURL: () => Promise<String>
}

export interface OwnerSubscription
  extends Promise<AsyncIterator<Owner>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  displayName: () => Promise<AsyncIterator<String>>
  username: () => Promise<AsyncIterator<String>>
  photoURL: () => Promise<AsyncIterator<String>>
}

export interface CommentSubscriptionPayload {
  mutation: MutationType
  node: Comment
  updatedFields: String[]
  previousValues: CommentPreviousValues
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = CommentPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = CommentPreviousValuesPromise>() => T
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = CommentSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = CommentPreviousValuesSubscription>() => T
}

export interface UserConnection {
  pageInfo: PageInfo
  edges: UserEdge[]
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<UserEdge>>() => T
  aggregate: <T = AggregateUserPromise>() => T
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T
  aggregate: <T = AggregateUserSubscription>() => T
}

export interface CommentPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  text: String
  ownerId?: String
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  text: () => Promise<String>
  ownerId: () => Promise<String>
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  text: () => Promise<AsyncIterator<String>>
  ownerId: () => Promise<AsyncIterator<String>>
}

export interface ServiceEdge {
  node: Service
  cursor: String
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T
  cursor: () => Promise<String>
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor?: String
  endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>
  hasPreviousPage: () => Promise<Boolean>
  startCursor: () => Promise<String>
  endCursor: () => Promise<String>
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
  startCursor: () => Promise<AsyncIterator<String>>
  endCursor: () => Promise<AsyncIterator<String>>
}

export interface ReviewConnection {
  pageInfo: PageInfo
  edges: ReviewEdge[]
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ReviewEdge>>() => T
  aggregate: <T = AggregateReviewPromise>() => T
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T
  aggregate: <T = AggregateReviewSubscription>() => T
}

export interface Review {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  rate?: Int
  rating: Int
  text: String
  serviceId: String
  ownerId?: String
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  rate: () => Promise<Int>
  rating: () => Promise<Int>
  text: () => Promise<String>
  serviceId: () => Promise<String>
  service: <T = ServicePromise>() => T
  ownerId: () => Promise<String>
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  rate: () => Promise<AsyncIterator<Int>>
  rating: () => Promise<AsyncIterator<Int>>
  text: () => Promise<AsyncIterator<String>>
  serviceId: () => Promise<AsyncIterator<String>>
  service: <T = ServiceSubscription>() => T
  ownerId: () => Promise<AsyncIterator<String>>
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType
  node: Review
  updatedFields: String[]
  previousValues: ReviewPreviousValues
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ReviewPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ReviewPreviousValuesPromise>() => T
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ReviewSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ReviewPreviousValuesSubscription>() => T
}

export interface CategoryConnection {
  pageInfo: PageInfo
  edges: CategoryEdge[]
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<CategoryEdge>>() => T
  aggregate: <T = AggregateCategoryPromise>() => T
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T
  aggregate: <T = AggregateCategorySubscription>() => T
}

export interface OwnerPreviousValues {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  displayName: String
  username: String
  photoURL?: String
}

export interface OwnerPreviousValuesPromise
  extends Promise<OwnerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  displayName: () => Promise<String>
  username: () => Promise<String>
  photoURL: () => Promise<String>
}

export interface OwnerPreviousValuesSubscription
  extends Promise<AsyncIterator<OwnerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  displayName: () => Promise<AsyncIterator<String>>
  username: () => Promise<AsyncIterator<String>>
  photoURL: () => Promise<AsyncIterator<String>>
}

export interface OwnerSubscriptionPayload {
  mutation: MutationType
  node: Owner
  updatedFields: String[]
  previousValues: OwnerPreviousValues
}

export interface OwnerSubscriptionPayloadPromise
  extends Promise<OwnerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = OwnerPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = OwnerPreviousValuesPromise>() => T
}

export interface OwnerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OwnerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = OwnerSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = OwnerPreviousValuesSubscription>() => T
}

export interface AggregateUser {
  count: Int
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface OwnerEdge {
  node: Owner
  cursor: String
}

export interface OwnerEdgePromise extends Promise<OwnerEdge>, Fragmentable {
  node: <T = OwnerPromise>() => T
  cursor: () => Promise<String>
}

export interface OwnerEdgeSubscription
  extends Promise<AsyncIterator<OwnerEdge>>,
    Fragmentable {
  node: <T = OwnerSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateReview {
  count: Int
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface User {
  id: ID_Output
  createdAt: DateTimeOutput
  updatedAt: DateTimeOutput
  name: String
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>
  createdAt: () => Promise<DateTimeOutput>
  updatedAt: () => Promise<DateTimeOutput>
  name: () => Promise<String>
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
  name: () => Promise<AsyncIterator<String>>
}

export type Long = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'User',
    embedded: false
  },
  {
    name: 'Owner',
    embedded: false
  },
  {
    name: 'Comment',
    embedded: false
  },
  {
    name: 'Review',
    embedded: false
  },
  {
    name: 'Category',
    embedded: false
  },
  {
    name: 'Service',
    embedded: false
  }
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://subsclog-prisma.now.sh/default/default`,
  secret: `${process.env['SECRET']}`
})
export const prisma = new Prisma()
